{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD) – 오프라인 멀티모달 챗봇 앱\n\n## 1. 개요\n본 앱은 사용자의 스마트폰 CPU·GPU를 활용해 오프라인에서도 동작하는 멀티모달 챗봇이다. Google Gemma 3n 모델을 온디바이스로 탑재해 텍스트·이미지·음성 입력을 처리하며, 온라인 환경에서는 Upstage Solar Pro 2 모델로 확장된 성능을 제공한다. 데이터 비용과 개인정보 노출 우려를 최소화하며, 언제 어디서나 AI를 활용하고 싶은 이용자에게 경제적·편리한 경험을 제공한다.\n\n## 2. 문제 정의\n- 클라우드 기반 AI 서비스는 지속적 네트워크 연결·구독 비용이 필요하다.  \n- 오프라인 환경(비행기, 산간, 해외 로밍 제한)에서는 챗봇 사용이 불가하다.  \n- 개인정보 및 민감 데이터가 서버로 전송되어 보안·프라이버시 우려가 존재한다.\n\n## 3. 목표 및 목적\n- 1차 목표: 네트워크 미연결 상태에서도 자연스러운 대화·멀티모달 이해·생성을 지원.  \n- 2차 목표: 온라인 연결 시 상위 모델로 자동 전환해 정확도·속도 향상.  \n- 성공 지표  \n  - DAU 10만 명(출시 6개월)  \n  - 세션당 평균 응답 시간 오프라인 2초 이하  \n  - 유료 광고 없음 기준 월 유지율 40% 이상  \n  - NPS 50 이상  \n\n## 4. 타깃 사용자\n### 주요 사용자\n- 데이터 요금·프라이버시 민감한 20~40대 스마트폰 사용자  \n- 비행 승무원, 군인, 해외 출장 잦은 직장인  \n- 개발자·학생 등 AI 탐구·테스트 목적으로 로컬 실행을 원하는 층  \n\n### 이차 사용자\n- 오프라인 환경 대상 B2B 사업자(교육, 의료, 제조 현장)  \n- 통신 불안정 지역 지자체·NGO  \n\n## 5. 사용자 스토리\n- “여행 중 기내에서, 나는 인터넷 없이도 영어 회화 교정을 받고 싶다.”  \n- “보안 구역 근무자로서, 외부 서버로 데이터 유출 없이 문서를 요약하고 싶다.”  \n- “사진을 찍어 재료를 인식하고 요리 레시피를 즉시 받아보고 싶다.”  \n- “온라인 연결 시 더 빠른 응답을 위해 클라우드 모델로 자동 전환되길 원한다.”  \n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 오프라인 모델 실행  \n   - 설명: Gemma 3n(≈3B 파라미터) 로컬 추론. 텍스트, 이미지, 음성 입력 지원.  \n   - 수용 기준  \n     - 디바이스 RAM 6GB 이상에서 추론 오류 1% 이하  \n     - 텍스트 50토큰 기준 응답 ≤2초  \n\n2. 온라인 모델 전환  \n   - 설명: 네트워크 감지 시 Solar Pro 2 API 호출로 품질·속도 최적.  \n   - 수용 기준  \n     - 전환 시 세션 유지(컨텍스트 손실 0건)  \n     - 응답 품질 BLEU/ROUGE 10% ↑(오프라인 대비)  \n\n3. 모달 통합 UI  \n   - 설명: 텍스트 입력, 마이크, 카메라 버튼 통합. 입력 형태 자동 감지.  \n   - 수용 기준  \n     - 이미지 인식 정확도 85%↑  \n     - 음성 인식 WER ≤7%  \n\n4. 프라이버시 모드  \n   - 설명: 모든 데이터 오프라인 저장, 암호화(Apple Secure Enclave).  \n   - 수용 기준  \n     - OWASP Mobile Top10 취약점 0건  \n\n### 지원 기능\n- 대화 히스토리 로컬 검색·태그  \n- 모델 관리(ON/OFF, 용량 확인)  \n- 배터리 세이브 모드(저전력 시 추론 양 줄이기)  \n- 다국어 UI(한국어 기본, 영어·일본어)  \n\n### Nice-to-Have 제안\n- 온디바이스 파인튜닝(사용자 문체 학습)  \n- Apple Vision Pro 대응 공간 컴퓨팅 UI  \n- 커뮤니티 공유 프롬프트 마켓플레이스  \n\n## 7. 비기능 요구사항\n- 성능: iPhone 12 기준 초반 로딩 ≤5초, FPS 30↑(카메라).  \n- 보안: Keychain 기반 토큰 저장, TLS 1.3, offline 모드 완전 차단(외부 전송).  \n- 사용성: iOS Human Interface Guidelines 준수, 다크모드 100%.  \n- 확장성: Core ML 모델 교체를 고려한 모듈형 구조.  \n- 호환성: iOS 15+, iPadOS, Apple Silicon Mac(유니버설).  \n\n## 8. 기술 고려사항\n- 아키텍처: Swift + SwiftUI, MVVM, Combine.  \n- 온디바이스 추론: Metal Performance Shaders, Core ML Stable Diffusion pipeline 변형.  \n- 모델 압축: 4bit quantization, LoRA adapter.  \n- 음성: Apple Speech framework, offline acoustic model.  \n- 이미지: VisionKit + Core ML.  \n- 서버: Online 모드용 RESTful API(GRPC 준비).  \n- 데이터: 로컬 Realm DB, iCloud 백업 선택적.  \n- 서드파티: Upstage Solar Pro 2, Firebase Crashlytics(익명).  \n\n```swift\n// 예시 모델 로딩 코드\nlet config = MLModelConfiguration()\nconfig.computeUnits = .cpuAndNeuralEngine\nlet gemma = try MLModel(contentsOf: gemmaURL, configuration: config)\n```\n\n## 9. 성공 측정 지표\n- 기술: 평균 응답 시간, 모델 전환 성공률 99%↑  \n- 사용자: 세션당 평균 대화 수 8회↑, 일간 재방문율 60%↑  \n- 비즈니스: 광고/구독 전환율 5%, 서버 비용 대비 ROI 300%  \n\n## 10. 일정 및 마일스톤\n- 1단계(M0~M2) MVP  \n  - Gemma 3n 통합, 텍스트 대화, 기본 UI  \n- 2단계(M3~M5) 멀티모달·온라인 전환  \n  - 이미지·음성, Solar Pro 2 API, 배포 TestFlight  \n- 3단계(M6~M8) 글로벌 출시  \n  - 다국어, 파인튜닝, 구독 모델, 마켓플레이스 베타  \n\n## 11. 위험 및 대응\n- 모델 크기 과대 → 4bit 압축·옵션 다운로드  \n- 배터리 소모 → 프레임 줄임, GPU Scheduling  \n- 앱스토어 심사 거절(저장 공간) → Lite 버전 배포  \n- 법적 규제(개인정보) → 온디바이스 저장·삭제 옵션 제공  \n\n## 12. 향후 고려 사항\n- Android·Windows 포팅(Kotlin, Electron)  \n- Federated Learning으로 사용자 피드백 반영  \n- 웨어러블(Watch, CarPlay) 확장  \n- LLM+검색(RAG) 통합 오프라인 코사이니드 인덱스 구축  ",
      "writedAt": "2025-07-20T14:37:10.115Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  본 프로젝트는 iOS 기기(CPU·GPU)를 활용한 오프라인 멀티모달 챗봇 앱으로, 로컬에 탑재된 Gemma 3n 모델로 텍스트·이미지·음성 입력을 처리하고, 온라인 환경에서는 Upstage Solar Pro 2 API를 호출하여 품질 및 속도를 향상시킵니다. 개인정보는 온디바이스에 암호화 저장하며, Firebase Auth와 Toss Payments를 연동합니다.\n- **핵심 기술 스택**  \n  Swift 5.7+, SwiftUI, Combine, MVVM, Core ML 3+, Metal Performance Shaders, VisionKit, Apple Speech, Realm DB, Firebase(인증·Crashlytics), Toss Payments, GitHub Actions, SwiftPM\n- **주요 기술 목표**  \n  - 오프라인 평균 응답 시간 ≤2초  \n  - 온라인 전환 시 컨텍스트 손실 0건, BLEU/ROUGE 10%↑  \n  - 메모리 6GB 이상 환경에서 추론 오류율 ≤1%  \n  - OWASP Mobile Top10 0건\n- **핵심 가정**  \n  - 대상 iOS 기기는 iOS 15 이상, Apple Silicon 또는 A 시리즈 칩셋  \n  - 네트워크 감지 후 API 호출 지연 시간 ≤200ms  \n  - 로컬 저장소(Realm) 및 iCloud 백업 권한 획득\n\n---\n\n## 2. Tech Stack\n\n| Category              | Technology / Library          | Reasoning (선택 이유)                                      |\n| --------------------- | ----------------------------- | --------------------------------------------------------- |\n| 언어 및 런타임         | Swift 5.7+                    | iOS 정식 지원, SwiftUI·Combine 연계 용이                   |\n| UI 프레임워크          | SwiftUI                       | iOS Human Interface Guidelines 준수, 다크모드 지원 용이     |\n| 상태 관리             | Combine + MVVM                | 반응형 UI 구현, ViewModel 분리로 테스트·유지보수 편의        |\n| 온디바이스 ML 엔진      | Core ML 3+ / Metal Performance Shaders | 모델 추론 최적화, GPU · Neural Engine 활용                 |\n| 음성 처리             | Apple Speech Framework        | 오프라인 음성 인식 모델 내장, WER 관리 용이                |\n| 이미지 처리           | VisionKit + Core ML           | 카메라 통합, 이미지 전처리 및 ML 파이프라인 연동            |\n| 로컬 데이터베이스       | Realm DB v10+                 | 경량, 오프라인 데이터 저장·검색 최적화                     |\n| 암호화 저장           | Apple Secure Enclave (Keychain) | 사용자 데이터·토큰 안전 저장                                 |\n| 인증 및 분석           | Firebase Auth (Google 로그인) / Crashlytics | 소셜 로그인 및 안정성 모니터링 제공                         |\n| 결제 연동             | Toss Payments SDK             | 국내 간편 결제 지원                                         |\n| API 통신              | RESTful API (URLSession)      | 서버리스 함수(Firebase Functions)로 Solar Pro 2 API 호출 준비 |\n| 패키지 관리           | Swift Package Manager         | Monorepo 내 모듈 버전 관리 용이                             |\n| CI/CD                | GitHub Actions                | iOS 빌드·테스트·배포 자동화                                |\n\n---\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- **앱 클라이언트 (iOS/macOS 유니버설)**\n  - Presentation Layer (SwiftUI View)\n  - Domain Layer (비즈니스 로직, Use Case)\n  - Data Layer (로컬 Realm, Core ML 추론, 원격 API)\n- **온디바이스 추론 엔진**\n  - Gemma 3n Core ML 모델 + Quantization 모듈\n  - Metal Performance Shaders 최적화\n- **원격 API 서버리스 함수**\n  - Solar Pro 2 호출 래퍼 (Firebase Functions)\n  - 인증 및 결제 트리거 엔드포인트\n- **클라우드 서비스**\n  - Firebase Auth, Crashlytics\n  - Toss Payments 인증·결제\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    U[사용자 (iOS)] -->|입력 요청| A[UI Layer]\n    A --> B[Domain Layer]\n    B --> C[On-Device ML Engine]\n    B --> D[Realm DB]\n    B --> E[Remote API (Solar Pro 2)]\n    E --> F[Firebase Functions]\n    F --> G[Upstage Solar Pro 2]\n```\n- 사용자가 UI를 통해 텍스트·이미지·음성 입력  \n- 도메인 로직이 온디바이스 ML 엔진 또는 로컬 DB 호출  \n- 온라인 전환 시 서버리스 함수 경유 Solar Pro 2 API 호출  \n- 결과를 도메인 레이어로 전달하여 화면에 렌더링  \n\n### Code Organization & Convention\n\n**도메인 중심 조직 전략**\n- **도메인 구분**: Chat, User, Media, Payment, Analytics  \n- **레이어 분리**: Presentation → Domain → Data → Infrastructure  \n- **기능 모듈화**: 각각의 도메인을 Swift 패키지로 분리  \n- **공통 모듈**: Utilities, Extensions, Networking, Models\n\n**모노레포 파일 구조 예시**\n```\n/\n├── apps\n│   ├── iOSApp\n│   │   ├── Sources\n│   │   └── Resources\n│   └── MacApp\n├── libs\n│   ├── Core (Utilities, Extensions)\n│   ├── Domain\n│   │   ├── Chat\n│   │   ├── User\n│   │   ├── Media\n│   │   └── Payment\n│   ├── Data\n│   │   ├── Local (Realm)\n│   │   └── Remote (API, Firebase)\n│   └── UIComponents\n├── scripts\n│   ├── build.sh\n│   └── deploy.sh\n├── Package.swift\n├── fastlane\n│   └── Fastfile\n└── .github\n    └── workflows\n        └── ci.yml\n```\n\n### Data Flow & Communication Patterns\n- **클라이언트-서버 통신**: URLSession 기반 RESTful 요청/응답  \n- **DB 상호작용**: Realm Transaction, Query 및 옵저버 패턴  \n- **외부 서비스 연동**: Firebase Functions으로 Solar Pro 2 Proxy  \n- **실시간 통신**: 해당 기능 필요 시 Combine 퍼블리셔/구독 활용  \n- **데이터 동기화**: iCloud 백업 선택 시 Realm 파일 자동 동기화  \n\n---\n\n## 4. Performance & Optimization Strategy\n- 모델 로딩 시 Background Thread & Progress Indicator 제공  \n- Metal Performance Shaders를 통한 GPU 연산 최적화  \n- Core ML 양자화(4bit) + LoRA Adapter 적용으로 모델 경량화  \n- Realm DB Lazy Loading 및 인덱싱으로 검색 성능 보장  \n\n---\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (M0~M2)\n- **Core Infrastructure**: Monorepo 설정, SwiftPM 패키지 구성, GitHub Actions CI  \n- **Essential Features**: Gemma 3n 텍스트 기반 오프라인 대화, 기본 UI  \n- **Basic Security**: Keychain/Enclave 암호화, Firebase Auth 연동  \n- **개발 환경**: Xcode · Fastlane · TestFlight 배포 기본 설정  \n- **Timeline**: 2개월\n\n### Phase 2: Feature Enhancement (M3~M5)\n- **Advanced Features**: 이미지·음성 입력 처리, 모달 통합 UI  \n- **온라인 전환**: Firebase Functions → Solar Pro 2 API, 컨텍스트 유지  \n- **Enhanced Security**: OWASP Mobile Top10 점검, 암호화 강화  \n- **Monitoring Implementation**: Crashlytics 대시보드 구성  \n- **Timeline**: 3개월\n\n### Phase 3: Scaling & Optimization (M6~M8)\n- **Scalability Implementation**: macOS 유니버설 앱, iCloud 백업 최적화  \n- **Advanced Integrations**: Toss Payments, 다국어 UI(영어·일본어)  \n- **Enterprise Features**: 배터리 세이브 모드, 모델 관리 UI  \n- **Compliance & Auditing**: 데이터 삭제·백업 정책 구현  \n- **Timeline**: 3개월\n\n---\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- 기술 리스크: 모델 양자화 시 품질 저하 → LoRA 보정 및 A/B 테스트  \n- 성능 리스크: 고사양 기기별 메모리 과부하 → 프로파일링 및 동적 스레드 제어  \n- 보안 리스크: 키 관리 취약 → Secure Enclave + 정기 감사  \n- 통합 리스크: Toss Payments SDK 충돌 → 샌드박스 테스트 및 예비 결제 수단 마련  \n- **Mitigation**: 주기적 성능 테스트, 코드 리뷰·정적 분석 자동화\n\n### Project Delivery Risks\n- 일정 리스크: iOS 리뷰 지연 → Lite 버전 사전 제출  \n- 리소스 리스크: ML 온디바이스 전문성 부족 → 외부 컨설팅 및 사내 교육  \n- 품질 리스크: 테스트 커버리지 부족 → XCTest·UI 테스트 자동화 강화  \n- 배포 리스크: 인증서·프로비저닝 문제 → Fastlane 자동화 및 롤백 플랜 준비  \n- **Contingency**: 예비 모델 서버 연결, 주요 기능 우선순위 조정  \n\n---\n\n*끝*",
      "writedAt": "2025-07-20T14:37:10.116Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-20T14:37:10.116Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-20T14:37:10.116Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-20T14:37:10.116Z"
    }
  ]
}